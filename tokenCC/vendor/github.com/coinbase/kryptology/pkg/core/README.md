<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# core

```go
import "github.com/coinbase/kryptology/pkg/core"
```

## Index

- [Constants](<#constants>)
- [Variables](<#variables>)
- [func Add(x, y, m *big.Int) (*big.Int, error)](<#func-add>)
- [func AnyNil(values ...*big.Int) bool](<#func-anynil>)
- [func Commit(msg []byte) (Commitment, *Witness, error)](<#func-commit>)
- [func ComputeHMAC(f func() hash.Hash, msg []byte, k []byte) ([]byte, error)](<#func-computehmac>)
- [func ConstantTimeEq(a, b *big.Int) bool](<#func-constanttimeeq>)
- [func ConstantTimeEqByte(a, b *big.Int) byte](<#func-constanttimeeqbyte>)
- [func Exp(x, y, m *big.Int) (*big.Int, error)](<#func-exp>)
- [func ExpandMessageXmd(f func() hash.Hash, msg, DST []byte, lenInBytes int) ([]byte, error)](<#func-expandmessagexmd>)
- [func FiatShamir(values ...*big.Int) ([]byte, error)](<#func-fiatshamir>)
- [func GenerateSafePrime(bits uint) (*big.Int, error)](<#func-generatesafeprime>)
- [func Hash(msg []byte, curve elliptic.Curve) (*big.Int, error)](<#func-hash>)
- [func I2OSP(b, n int) []byte](<#func-i2osp>)
- [func In(x, m *big.Int) error](<#func-in>)
- [func Inv(x, m *big.Int) (*big.Int, error)](<#func-inv>)
- [func Mul(x, y, m *big.Int) (*big.Int, error)](<#func-mul>)
- [func Neg(x, m *big.Int) (*big.Int, error)](<#func-neg>)
- [func OS2IP(os []byte) *big.Int](<#func-os2ip>)
- [func Open(c Commitment, d Witness) (bool, error)](<#func-open>)
- [func Rand(m *big.Int) (*big.Int, error)](<#func-rand>)
- [type Commitment](<#type-commitment>)
- [type HashField](<#type-hashfield>)
- [type Params](<#type-params>)
- [type Witness](<#type-witness>)
  - [func (w Witness) MarshalJSON() ([]byte, error)](<#func-witness-marshaljson>)
  - [func (w *Witness) UnmarshalJSON(data []byte) error](<#func-witness-unmarshaljson>)


## Constants

Size of random values and hash outputs are determined by our hash function

```go
const Size = sha256.Size
```

## Variables

```go
var (
    // Zero is additive identity in the set of integers
    Zero = big.NewInt(0)

    // One is the multiplicative identity in the set of integers
    One = big.NewInt(1)

    // Two is the odd prime
    Two = big.NewInt(2)
)
```

## func [Add](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L85>)

```go
func Add(x, y, m *big.Int) (*big.Int, error)
```

Add \(modular addition\): z = x\+y \(modulo m\)

## func [AnyNil](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L168>)

```go
func AnyNil(values ...*big.Int) bool
```

AnyNil determines if any of values are nil

## func [Commit](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L60>)

```go
func Commit(msg []byte) (Commitment, *Witness, error)
```

Commit to a given message\. Uses SHA256 as the hash function\.

## func [ComputeHMAC](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L101>)

```go
func ComputeHMAC(f func() hash.Hash, msg []byte, k []byte) ([]byte, error)
```

ComputeHMAC computes HMAC\(hash\_fn\, msg\, key\) Takes in a hash function to use for HMAC

## func [ConstantTimeEq](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L65>)

```go
func ConstantTimeEq(a, b *big.Int) bool
```

ConstantTimeEq determines if a\, b have identical byte serialization and uses the crypto/subtle package to get a constant time comparison over byte representations\.

## func [ConstantTimeEqByte](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L35>)

```go
func ConstantTimeEqByte(a, b *big.Int) byte
```

ConstantTimeEqByte determines if a\, b have identical byte serialization and signs\. It uses the crypto/subtle package to get a constant time comparison over byte representations\. Return value is a byte which may be useful in bitwise operations\. Returns 0x1 if the two values have the identical sign and byte representation; 0x0 otherwise\.

## func [Exp](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L114>)

```go
func Exp(x, y, m *big.Int) (*big.Int, error)
```

Exp \(modular exponentiation\): z = x^y \(modulo m\)

## func [ExpandMessageXmd](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L123>)

```go
func ExpandMessageXmd(f func() hash.Hash, msg, DST []byte, lenInBytes int) ([]byte, error)
```

## func [FiatShamir](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L247>)

```go
func FiatShamir(values ...*big.Int) ([]byte, error)
```

fiatShamir computes the HKDF over many values iteratively such that each value is hashed separately and based on preceding values

### The first value is computed as okm\_0 = KDF\(f || value\) where
f is a byte slice of 32 0xFF
salt is zero\-filled byte slice with length equal to the hash output length
info is the protocol name
okm is the 32 byte output

The each subsequent iteration is computed by as okm\_i = KDF\(f\_i || value || okm\_\{i\-1\}\) where f\_i = 2^b \- 1 \- i such that there are 0xFF bytes prior to the value\. f\_1 changes the first byte to 0xFE\, f\_2 to 0xFD\. The previous okm is appended to the value to provide cryptographic domain separation See https://signal.org/docs/specifications/x3dh/#cryptographic-notation and https://signal.org/docs/specifications/xeddsa/#hash-functions for more details\. This uses the KDF function similar to X3DH for each \`value\` But changes the key just like XEdDSA where the prefix bytes change by a single bit

## func [GenerateSafePrime](<https://github.com/coinbase/kryptology/blob/master/pkg/core/primes.go#L18>)

```go
func GenerateSafePrime(bits uint) (*big.Int, error)
```

GenerateSafePrime creates a prime number \`p\` where \(\`p\`\-1\)/2 is also prime with at least \`bits\`

## func [Hash](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L220>)

```go
func Hash(msg []byte, curve elliptic.Curve) (*big.Int, error)
```

## func [I2OSP](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L78>)

```go
func I2OSP(b, n int) []byte
```

## func [In](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L71>)

```go
func In(x, m *big.Int) error
```

In determines ring membership before modular reduction: x ∈ Z\_m returns nil if 0 ≤ x \< m

## func [Inv](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L133>)

```go
func Inv(x, m *big.Int) (*big.Int, error)
```

Inv \(modular inverse\): returns y such that xy = 1 \(modulo m\)\.

## func [Mul](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L99>)

```go
func Mul(x, y, m *big.Int) (*big.Int, error)
```

Mul \(modular multiplication\): z = x\*y \(modulo m\)

## func [Neg](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L123>)

```go
func Neg(x, m *big.Int) (*big.Int, error)
```

Neg \(modular negation\): z = \-x \(modulo m\)

## func [OS2IP](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L89>)

```go
func OS2IP(os []byte) *big.Int
```

## func [Open](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L85>)

```go
func Open(c Commitment, d Witness) (bool, error)
```

Open a commitment and return true if the commitment/decommitment pair are valid\. reference: spec\.§2\.4: Commitment Scheme

## func [Rand](<https://github.com/coinbase/kryptology/blob/master/pkg/core/mod.go#L145>)

```go
func Rand(m *big.Int) (*big.Int, error)
```

Rand generates a cryptographically secure random integer in the range: 1 \< r \< m\.

## type [Commitment](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L26>)

Commitment to a given message which can be later revealed\. This is sent to and held by a verifier until the corresponding witness is provided\.

```go
type Commitment []byte
```

## type [HashField](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L24-L29>)

```go
type HashField struct {
    // F_p^k
    Order           *big.Int // p^k
    Characteristic  *big.Int // p
    ExtensionDegree *big.Int // k
}
```

## type [Params](<https://github.com/coinbase/kryptology/blob/master/pkg/core/hash.go#L31-L36>)

```go
type Params struct {
    F                 *HashField
    SecurityParameter int
    Hash              func() hash.Hash
    L                 int
}
```

## type [Witness](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L30-L33>)

Witness is sent to and opened by the verifier\. This proves that committed message hasn't been altered by later information\.

```go
type Witness struct {
    Msg []byte
    // contains filtered or unexported fields
}
```

### func \(Witness\) [MarshalJSON](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L43>)

```go
func (w Witness) MarshalJSON() ([]byte, error)
```

MarshalJSON encodes Witness in JSON

### func \(\*Witness\) [UnmarshalJSON](<https://github.com/coinbase/kryptology/blob/master/pkg/core/commit.go#L48>)

```go
func (w *Witness) UnmarshalJSON(data []byte) error
```

UnmarshalJSON decodes JSON into a Witness struct



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
