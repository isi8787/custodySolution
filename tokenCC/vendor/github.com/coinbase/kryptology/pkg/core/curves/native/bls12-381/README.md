<!-- Code generated by gomarkdoc. DO NOT EDIT -->

# bls12381

```go
import "github.com/coinbase/kryptology/pkg/core/curves/native/bls12-381"
```

## Index

- [Variables](<#variables>)
- [type E](<#type-e>)
  - [func (g *E) Equal(g2 *E) bool](<#func-e-equal>)
  - [func (e *E) IsOne() bool](<#func-e-isone>)
  - [func (e *E) One() *E](<#func-e-one>)
  - [func (e *E) Set(e2 *E) *E](<#func-e-set>)
- [type Engine](<#type-engine>)
  - [func NewEngine() *Engine](<#func-newengine>)
  - [func (e *Engine) AddPair(g1 *PointG1, g2 *PointG2) *Engine](<#func-engine-addpair>)
  - [func (e *Engine) AddPairInv(g1 *PointG1, g2 *PointG2) *Engine](<#func-engine-addpairinv>)
  - [func (e *Engine) Check() (bool, error)](<#func-engine-check>)
  - [func (e *Engine) GT() *GT](<#func-engine-gt>)
  - [func (e *Engine) Reset() *Engine](<#func-engine-reset>)
  - [func (e *Engine) Result() (*E, error)](<#func-engine-result>)
- [type G1](<#type-g1>)
  - [func NewG1() *G1](<#func-newg1>)
  - [func (g *G1) Add(r, p1, p2 *PointG1) *PointG1](<#func-g1-add>)
  - [func (g *G1) Affine(p *PointG1) *PointG1](<#func-g1-affine>)
  - [func (g *G1) ClearCofactor(p *PointG1)](<#func-g1-clearcofactor>)
  - [func (g *G1) Double(r, p *PointG1) *PointG1](<#func-g1-double>)
  - [func (g *G1) EncodeToCurve(f func() hash.Hash, msg, domain []byte) (*PointG1, error)](<#func-g1-encodetocurve>)
  - [func (g *G1) Equal(p1, p2 *PointG1) bool](<#func-g1-equal>)
  - [func (g *G1) FromBytes(in []byte) (*PointG1, error)](<#func-g1-frombytes>)
  - [func (g *G1) FromCompressed(compressed []byte) (*PointG1, error)](<#func-g1-fromcompressed>)
  - [func (g *G1) FromUncompressed(uncompressed []byte) (*PointG1, error)](<#func-g1-fromuncompressed>)
  - [func (g *G1) HashToCurve(f func() hash.Hash, msg, domain []byte) (*PointG1, error)](<#func-g1-hashtocurve>)
  - [func (g *G1) InCorrectSubgroup(p *PointG1) bool](<#func-g1-incorrectsubgroup>)
  - [func (g *G1) IsAffine(p *PointG1) bool](<#func-g1-isaffine>)
  - [func (g *G1) IsOnCurve(p *PointG1) bool](<#func-g1-isoncurve>)
  - [func (g *G1) IsZero(p *PointG1) bool](<#func-g1-iszero>)
  - [func (g *G1) MapToCurve(in []byte) (*PointG1, error)](<#func-g1-maptocurve>)
  - [func (g *G1) MulScalar(c, p *PointG1, e *big.Int) *PointG1](<#func-g1-mulscalar>)
  - [func (g *G1) MultiExp(r *PointG1, points []*PointG1, powers []*big.Int) (*PointG1, error)](<#func-g1-multiexp>)
  - [func (g *G1) Neg(r, p *PointG1) *PointG1](<#func-g1-neg>)
  - [func (g *G1) New() *PointG1](<#func-g1-new>)
  - [func (g *G1) One() *PointG1](<#func-g1-one>)
  - [func (g *G1) Q() *big.Int](<#func-g1-q>)
  - [func (g *G1) Sub(c, a, b *PointG1) *PointG1](<#func-g1-sub>)
  - [func (g *G1) ToBytes(p *PointG1) []byte](<#func-g1-tobytes>)
  - [func (g *G1) ToCompressed(p *PointG1) []byte](<#func-g1-tocompressed>)
  - [func (g *G1) ToUncompressed(p *PointG1) ([]byte, error)](<#func-g1-touncompressed>)
  - [func (g *G1) Zero() *PointG1](<#func-g1-zero>)
- [type G2](<#type-g2>)
  - [func NewG2() *G2](<#func-newg2>)
  - [func (g *G2) Add(r, p1, p2 *PointG2) *PointG2](<#func-g2-add>)
  - [func (g *G2) Affine(p *PointG2) *PointG2](<#func-g2-affine>)
  - [func (g *G2) ClearCofactor(p *PointG2) *PointG2](<#func-g2-clearcofactor>)
  - [func (g *G2) Double(r, p *PointG2) *PointG2](<#func-g2-double>)
  - [func (g *G2) EncodeToCurve(f func() hash.Hash, msg, domain []byte) (*PointG2, error)](<#func-g2-encodetocurve>)
  - [func (g *G2) Equal(p1, p2 *PointG2) bool](<#func-g2-equal>)
  - [func (g *G2) FromBytes(in []byte) (*PointG2, error)](<#func-g2-frombytes>)
  - [func (g *G2) FromCompressed(compressed []byte) (*PointG2, error)](<#func-g2-fromcompressed>)
  - [func (g *G2) FromUncompressed(uncompressed []byte) (*PointG2, error)](<#func-g2-fromuncompressed>)
  - [func (g *G2) HashToCurve(f func() hash.Hash, msg, domain []byte) (*PointG2, error)](<#func-g2-hashtocurve>)
  - [func (g *G2) InCorrectSubgroup(p *PointG2) bool](<#func-g2-incorrectsubgroup>)
  - [func (g *G2) IsAffine(p *PointG2) bool](<#func-g2-isaffine>)
  - [func (g *G2) IsOnCurve(p *PointG2) bool](<#func-g2-isoncurve>)
  - [func (g *G2) IsZero(p *PointG2) bool](<#func-g2-iszero>)
  - [func (g *G2) MapToCurve(in []byte) (*PointG2, error)](<#func-g2-maptocurve>)
  - [func (g *G2) MulScalar(c, p *PointG2, e *big.Int) *PointG2](<#func-g2-mulscalar>)
  - [func (g *G2) MultiExp(r *PointG2, points []*PointG2, powers []*big.Int) (*PointG2, error)](<#func-g2-multiexp>)
  - [func (g *G2) Neg(r, p *PointG2) *PointG2](<#func-g2-neg>)
  - [func (g *G2) New() *PointG2](<#func-g2-new>)
  - [func (g *G2) One() *PointG2](<#func-g2-one>)
  - [func (g *G2) Q() *big.Int](<#func-g2-q>)
  - [func (g *G2) Sub(c, a, b *PointG2) *PointG2](<#func-g2-sub>)
  - [func (g *G2) ToBytes(p *PointG2) []byte](<#func-g2-tobytes>)
  - [func (g *G2) ToCompressed(p *PointG2) []byte](<#func-g2-tocompressed>)
  - [func (g *G2) ToUncompressed(p *PointG2) ([]byte, error)](<#func-g2-touncompressed>)
  - [func (g *G2) Zero() *PointG2](<#func-g2-zero>)
- [type GT](<#type-gt>)
  - [func NewGT() *GT](<#func-newgt>)
  - [func (g *GT) Add(c, a, b *E)](<#func-gt-add>)
  - [func (g *GT) Exp(c, a *E, s *big.Int)](<#func-gt-exp>)
  - [func (g *GT) FromBytes(in []byte) (*E, error)](<#func-gt-frombytes>)
  - [func (g *GT) Inverse(c, a *E)](<#func-gt-inverse>)
  - [func (g *GT) IsValid(e *E) bool](<#func-gt-isvalid>)
  - [func (g *GT) Mul(c, a, b *E)](<#func-gt-mul>)
  - [func (g *GT) New() *E](<#func-gt-new>)
  - [func (g *GT) Q() *big.Int](<#func-gt-q>)
  - [func (g *GT) Square(c, a *E)](<#func-gt-square>)
  - [func (g *GT) Sub(c, a, b *E)](<#func-gt-sub>)
  - [func (g *GT) ToBytes(e *E) []byte](<#func-gt-tobytes>)
- [type PointG1](<#type-pointg1>)
  - [func (p *PointG1) Set(p2 *PointG1) *PointG1](<#func-pointg1-set>)
  - [func (p *PointG1) Zero() *PointG1](<#func-pointg1-zero>)
- [type PointG2](<#type-pointg2>)
  - [func (p *PointG2) Set(p2 *PointG2) *PointG2](<#func-pointg2-set>)
  - [func (p *PointG2) Zero() *PointG2](<#func-pointg2-zero>)


## Variables

```go
var G1One = g1One
```

```go
var G2One = g2One
```

Inp = \-p^\(\-1\) mod 2^64

```go
var Inp uint64 = 0x89f3fffcfffcfffd
```

## type [E](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L15>)

E is type for target group element

```go
type E = fe12
```

### func \(\*E\) [Equal](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L39>)

```go
func (g *E) Equal(g2 *E) bool
```

Equal returns true if given two element is equal\, otherwise returns false

### func \(\*E\) [IsOne](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L34>)

```go
func (e *E) IsOne() bool
```

IsOne returns true if given element equals to one

### func \(\*E\) [One](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L28>)

```go
func (e *E) One() *E
```

One sets a new target group element to one

### func \(\*E\) [Set](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L23>)

```go
func (e *E) Set(e2 *E) *E
```

Set copies given value into the destination

## type [Engine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L21-L28>)

Engine is BLS12\-381 elliptic curve pairing engine

```go
type Engine struct {
    G1  *G1
    G2  *G2
    // contains filtered or unexported fields
}
```

### func [NewEngine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L31>)

```go
func NewEngine() *Engine
```

NewEngine creates new pairing engine insteace\.

### func \(\*Engine\) [AddPair](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L62>)

```go
func (e *Engine) AddPair(g1 *PointG1, g2 *PointG2) *Engine
```

AddPair adds a g1\, g2 point pair to pairing engine returns nil if no more pairs can be added

### func \(\*Engine\) [AddPairInv](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L76>)

```go
func (e *Engine) AddPairInv(g1 *PointG1, g2 *PointG2) *Engine
```

AddPairInv adds a G1\, G2 point pair to pairing engine\. G1 point is negated\. returns nil if no more pairs can be added

### func \(\*Engine\) [Check](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L282>)

```go
func (e *Engine) Check() (bool, error)
```

Check computes pairing and checks if result is equal to one

### func \(\*Engine\) [GT](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L301>)

```go
func (e *Engine) GT() *GT
```

GT returns target group instance\.

### func \(\*Engine\) [Reset](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L86>)

```go
func (e *Engine) Reset() *Engine
```

Reset deletes added pairs\.

### func \(\*Engine\) [Result](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/pairing.go#L291>)

```go
func (e *Engine) Result() (*E, error)
```

Result computes pairing and returns target group element as result\.

## type [G1](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L41-L43>)

G1 is struct for G1 group\.

```go
type G1 struct {
    // contains filtered or unexported fields
}
```

### func [NewG1](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L46>)

```go
func NewG1() *G1
```

NewG1 constructs a new G1 instance\.

### func \(\*G1\) [Add](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L392>)

```go
func (g *G1) Add(r, p1, p2 *PointG1) *PointG1
```

Add adds two G1 points p1\, p2 and assigns the result to point at first argument\.

### func \(\*G1\) [Affine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L375>)

```go
func (g *G1) Affine(p *PointG1) *PointG1
```

Add adds two G1 points p1\, p2 and assigns the result to point at first argument\.

### func \(\*G1\) [ClearCofactor](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L506>)

```go
func (g *G1) ClearCofactor(p *PointG1)
```

ClearCofactor maps given a G1 point to correct subgroup

### func \(\*G1\) [Double](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L441>)

```go
func (g *G1) Double(r, p *PointG1) *PointG1
```

Double doubles a G1 point p and assigns the result to the point at first argument\.

### func \(\*G1\) [EncodeToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L585>)

```go
func (g *G1) EncodeToCurve(f func() hash.Hash, msg, domain []byte) (*PointG1, error)
```

EncodeToCurve given a message and domain seperator tag returns the hash result which is a valid curve point\. Implementation follows BLS12381G1\_XMD:SHA\-256\_SSWU\_NU\_ suite at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-08

### func \(\*G1\) [Equal](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L326>)

```go
func (g *G1) Equal(p1, p2 *PointG1) bool
```

Equal checks if given two G1 point is equal in their affine form\.

### func \(\*G1\) [FromBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L221>)

```go
func (g *G1) FromBytes(in []byte) (*PointG1, error)
```

FromBytes constructs a new point given uncompressed byte input\. FromBytes does not take zcash flags into account\. Byte input expected to be larger than 96 bytes\. First 96 bytes should be concatenation of x and y values\. Point \(0\, 0\) is considered as infinity\.

### func \(\*G1\) [FromCompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L131>)

```go
func (g *G1) FromCompressed(compressed []byte) (*PointG1, error)
```

FromCompressed expects byte slice larger than 96 bytes and given bytes returns a new point in G1\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G1\) [FromUncompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L68>)

```go
func (g *G1) FromUncompressed(uncompressed []byte) (*PointG1, error)
```

FromUncompressed expects byte slice larger than 96 bytes and given bytes returns a new point in G1\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G1\) [HashToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L611>)

```go
func (g *G1) HashToCurve(f func() hash.Hash, msg, domain []byte) (*PointG1, error)
```

HashToCurve given a message and domain seperator tag returns the hash result which is a valid curve point\. Implementation follows BLS12381G1\_XMD:SHA\-256\_SSWU\_RO\_ suite at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-08

### func \(\*G1\) [InCorrectSubgroup](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L346>)

```go
func (g *G1) InCorrectSubgroup(p *PointG1) bool
```

InCorrectSubgroup checks whether given point is in correct subgroup\.

### func \(\*G1\) [IsAffine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L370>)

```go
func (g *G1) IsAffine(p *PointG1) bool
```

IsAffine checks a G1 point whether it is in affine form\.

### func \(\*G1\) [IsOnCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L353>)

```go
func (g *G1) IsOnCurve(p *PointG1) bool
```

IsOnCurve checks a G1 point is on curve\.

### func \(\*G1\) [IsZero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L316>)

```go
func (g *G1) IsZero(p *PointG1) bool
```

IsZero returns true if given point is equal to zero\.

### func \(\*G1\) [MapToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L568>)

```go
func (g *G1) MapToCurve(in []byte) (*PointG1, error)
```

MapToCurve given a byte slice returns a valid G1 point\. This mapping function implements the Simplified Shallue\-van de Woestijne\-Ulas method\. https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-08 Input byte slice should be a valid field element\, otherwise an error is returned\.

### func \(\*G1\) [MulScalar](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L489>)

```go
func (g *G1) MulScalar(c, p *PointG1, e *big.Int) *PointG1
```

MulScalar multiplies a point by given scalar value in big\.Int and assigns the result to point at first argument\.

### func \(\*G1\) [MultiExp](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L514>)

```go
func (g *G1) MultiExp(r *PointG1, points []*PointG1, powers []*big.Int) (*PointG1, error)
```

MultiExp calculates multi exponentiation\. Given pairs of G1 point and scalar values \(P\_0\, e\_0\)\, \(P\_1\, e\_1\)\, \.\.\. \(P\_n\, e\_n\) calculates r = e\_0 \* P\_0 \+ e\_1 \* P\_1 \+ \.\.\. \+ e\_n \* P\_n Length of points and scalars are expected to be equal\, otherwise an error is returned\. Result is assigned to point at first argument\.

### func \(\*G1\) [Neg](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L473>)

```go
func (g *G1) Neg(r, p *PointG1) *PointG1
```

Neg negates a G1 point p and assigns the result to the point at first argument\.

### func \(\*G1\) [New](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L300>)

```go
func (g *G1) New() *PointG1
```

New creates a new G1 Point which is equal to zero in other words point at infinity\.

### func \(\*G1\) [One](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L310>)

```go
func (g *G1) One() *PointG1
```

One returns a new G1 Point which is equal to generator point\.

### func \(\*G1\) [Q](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L60>)

```go
func (g *G1) Q() *big.Int
```

Q returns group order in big\.Int\.

### func \(\*G1\) [Sub](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L481>)

```go
func (g *G1) Sub(c, a, b *PointG1) *PointG1
```

Sub subtracts two G1 points p1\, p2 and assigns the result to point at first argument\.

### func \(\*G1\) [ToBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L251>)

```go
func (g *G1) ToBytes(p *PointG1) []byte
```

ToBytes serializes a point into bytes in uncompressed form\. ToBytes does not take zcash flags into account\. ToBytes returns \(0\, 0\) if point is infinity\.

### func \(\*G1\) [ToCompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L181>)

```go
func (g *G1) ToCompressed(p *PointG1) []byte
```

ToCompressed given a G1 point returns bytes in compressed form of the point\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G1\) [ToUncompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L112>)

```go
func (g *G1) ToUncompressed(p *PointG1) ([]byte, error)
```

ToUncompressed given a G1 point returns bytes in uncompressed \(x\, y\) form of the point\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G1\) [Zero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L305>)

```go
func (g *G1) Zero() *PointG1
```

Zero returns a new G1 Point which is equal to point at infinity\.

## type [G2](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L43-L46>)

G2 is struct for G2 group\.

```go
type G2 struct {
    // contains filtered or unexported fields
}
```

### func [NewG2](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L49>)

```go
func NewG2() *G2
```

NewG2 constructs a new G2 instance\.

### func \(\*G2\) [Add](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L399>)

```go
func (g *G2) Add(r, p1, p2 *PointG2) *PointG2
```

Add adds two G2 points p1\, p2 and assigns the result to point at first argument\.

### func \(\*G2\) [Affine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L382>)

```go
func (g *G2) Affine(p *PointG2) *PointG2
```

Affine calculates affine form of given G2 point\.

### func \(\*G2\) [ClearCofactor](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L513>)

```go
func (g *G2) ClearCofactor(p *PointG2) *PointG2
```

ClearCofactor maps given a G2 point to correct subgroup

### func \(\*G2\) [Double](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L448>)

```go
func (g *G2) Double(r, p *PointG2) *PointG2
```

Double doubles a G2 point p and assigns the result to the point at first argument\.

### func \(\*G2\) [EncodeToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L632>)

```go
func (g *G2) EncodeToCurve(f func() hash.Hash, msg, domain []byte) (*PointG2, error)
```

EncodeToCurve given a message and domain seperator tag returns the hash result which is a valid curve point\. Implementation follows BLS12381G1\_XMD:SHA\-256\_SSWU\_NU\_ suite at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-08

### func \(\*G2\) [Equal](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L333>)

```go
func (g *G2) Equal(p1, p2 *PointG2) bool
```

Equal checks if given two G2 point is equal in their affine form\.

### func \(\*G2\) [FromBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L231>)

```go
func (g *G2) FromBytes(in []byte) (*PointG2, error)
```

FromBytes constructs a new point given uncompressed byte input\. FromBytes does not take zcash flags into account\. Byte input expected to be larger than 96 bytes\. First 192 bytes should be concatenation of x and y values Point \(0\, 0\) is considered as infinity\.

### func \(\*G2\) [FromCompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L141>)

```go
func (g *G2) FromCompressed(compressed []byte) (*PointG2, error)
```

FromCompressed expects byte slice larger than 96 bytes and given bytes returns a new point in G2\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G2\) [FromUncompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L78>)

```go
func (g *G2) FromUncompressed(uncompressed []byte) (*PointG2, error)
```

FromUncompressed expects byte slice larger than 192 bytes and given bytes returns a new point in G2\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G2\) [HashToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L659>)

```go
func (g *G2) HashToCurve(f func() hash.Hash, msg, domain []byte) (*PointG2, error)
```

HashToCurve given a message and domain seperator tag returns the hash result which is a valid curve point\. Implementation follows BLS12381G1\_XMD:SHA\-256\_SSWU\_RO\_ suite at https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-08

### func \(\*G2\) [InCorrectSubgroup](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L353>)

```go
func (g *G2) InCorrectSubgroup(p *PointG2) bool
```

InCorrectSubgroup checks whether given point is in correct subgroup\.

### func \(\*G2\) [IsAffine](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L377>)

```go
func (g *G2) IsAffine(p *PointG2) bool
```

IsAffine checks a G2 point whether it is in affine form\.

### func \(\*G2\) [IsOnCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L360>)

```go
func (g *G2) IsOnCurve(p *PointG2) bool
```

IsOnCurve checks a G2 point is on curve\.

### func \(\*G2\) [IsZero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L323>)

```go
func (g *G2) IsZero(p *PointG2) bool
```

IsZero returns true if given point is equal to zero\.

### func \(\*G2\) [MapToCurve](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L614>)

```go
func (g *G2) MapToCurve(in []byte) (*PointG2, error)
```

MapToCurve given a byte slice returns a valid G2 point\. This mapping function implements the Simplified Shallue\-van de Woestijne\-Ulas method\. https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-05#section-6.6.2 Input byte slice should be a valid field element\, otherwise an error is returned\.

### func \(\*G2\) [MulScalar](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L496>)

```go
func (g *G2) MulScalar(c, p *PointG2, e *big.Int) *PointG2
```

MulScalar multiplies a point by given scalar value in big\.Int and assigns the result to point at first argument\.

### func \(\*G2\) [MultiExp](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L521>)

```go
func (g *G2) MultiExp(r *PointG2, points []*PointG2, powers []*big.Int) (*PointG2, error)
```

MultiExp calculates multi exponentiation\. Given pairs of G2 point and scalar values \(P\_0\, e\_0\)\, \(P\_1\, e\_1\)\, \.\.\. \(P\_n\, e\_n\) calculates r = e\_0 \* P\_0 \+ e\_1 \* P\_1 \+ \.\.\. \+ e\_n \* P\_n Length of points and scalars are expected to be equal\, otherwise an error is returned\. Result is assigned to point at first argument\.

### func \(\*G2\) [Neg](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L480>)

```go
func (g *G2) Neg(r, p *PointG2) *PointG2
```

Neg negates a G2 point p and assigns the result to the point at first argument\.

### func \(\*G2\) [New](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L307>)

```go
func (g *G2) New() *PointG2
```

New creates a new G2 Point which is equal to zero in other words point at infinity\.

### func \(\*G2\) [One](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L317>)

```go
func (g *G2) One() *PointG2
```

One returns a new G2 Point which is equal to generator point\.

### func \(\*G2\) [Q](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L70>)

```go
func (g *G2) Q() *big.Int
```

Q returns group order in big\.Int\.

### func \(\*G2\) [Sub](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L488>)

```go
func (g *G2) Sub(c, a, b *PointG2) *PointG2
```

Sub subtracts two G2 points p1\, p2 and assigns the result to point at first argument\.

### func \(\*G2\) [ToBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L261>)

```go
func (g *G2) ToBytes(p *PointG2) []byte
```

ToBytes serializes a point into bytes in uncompressed form\, does not take zcash flags into account\, returns \(0\, 0\) if point is infinity\.

### func \(\*G2\) [ToCompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L191>)

```go
func (g *G2) ToCompressed(p *PointG2) []byte
```

ToCompressed given a G2 point returns bytes in compressed form of the point\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G2\) [ToUncompressed](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L122>)

```go
func (g *G2) ToUncompressed(p *PointG2) ([]byte, error)
```

ToUncompressed given a G2 point returns bytes in uncompressed \(x\, y\) form of the point\. Serialization rules are in line with zcash library\. See below for details\. https://github.com/zcash/librustzcash/blob/master/pairing/src/bls12_381/README.md#serialization https://docs.rs/bls12_381/0.1.1/bls12_381/notes/serialization/index.html

### func \(\*G2\) [Zero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L312>)

```go
func (g *G2) Zero() *PointG2
```

Zero returns a new G2 Point which is equal to point at infinity\.

## type [GT](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L18-L20>)

GT is type for target multiplicative group GT\.

```go
type GT struct {
    // contains filtered or unexported fields
}
```

### func [NewGT](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L44>)

```go
func NewGT() *GT
```

NewGT constructs new target group instance\.

### func \(\*GT\) [Add](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L85>)

```go
func (g *GT) Add(c, a, b *E)
```

Add adds two field element \`a\` and \`b\` and assigns the result to the element in first argument\.

### func \(\*GT\) [Exp](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L105>)

```go
func (g *GT) Exp(c, a *E, s *big.Int)
```

Exp exponents an element \`a\` by a scalar \`s\` and assigns the result to the element in first argument\.

### func \(\*GT\) [FromBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L56>)

```go
func (g *GT) FromBytes(in []byte) (*E, error)
```

FromBytes expects 576 byte input and returns target group element FromBytes returns error if given element is not on correct subgroup\.

### func \(\*GT\) [Inverse](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L110>)

```go
func (g *GT) Inverse(c, a *E)
```

Inverse inverses an element \`a\` and assigns the result to the element in first argument\.

### func \(\*GT\) [IsValid](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L73>)

```go
func (g *GT) IsValid(e *E) bool
```

IsValid checks whether given target group element is in correct subgroup\.

### func \(\*GT\) [Mul](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L95>)

```go
func (g *GT) Mul(c, a, b *E)
```

Mul multiplies two field element \`a\` and \`b\` and assigns the result to the element in first argument\.

### func \(\*GT\) [New](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L80>)

```go
func (g *GT) New() *E
```

New initializes a new target group element which is equal to one

### func \(\*GT\) [Q](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L50>)

```go
func (g *GT) Q() *big.Int
```

Q returns group order in big\.Int\.

### func \(\*GT\) [Square](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L100>)

```go
func (g *GT) Square(c, a *E)
```

Square squares an element \`a\` and assigns the result to the element in first argument\.

### func \(\*GT\) [Sub](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L90>)

```go
func (g *GT) Sub(c, a, b *E)
```

Sub subtracts two field element \`a\` and \`b\`\, and assigns the result to the element in first argument\.

### func \(\*GT\) [ToBytes](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/gt.go#L68>)

```go
func (g *GT) ToBytes(e *E) []byte
```

ToBytes serializes target group element\.

## type [PointG1](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L20>)

PointG1 is type for point in G1\. PointG1 is both used for Affine and Jacobian point representation\. If z is equal to one the point is accounted as in affine form\.

```go
type PointG1 [3]fe
```

### func \(\*PointG1\) [Set](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L22>)

```go
func (p *PointG1) Set(p2 *PointG1) *PointG1
```

### func \(\*PointG1\) [Zero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g1.go#L29>)

```go
func (p *PointG1) Zero() *PointG1
```

## type [PointG2](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L20>)

PointG2 is type for point in G2\. PointG2 is both used for Affine and Jacobian point representation\. If z is equal to one the point is accounted as in affine form\.

```go
type PointG2 [3]fe2
```

### func \(\*PointG2\) [Set](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L23>)

```go
func (p *PointG2) Set(p2 *PointG2) *PointG2
```

Set copies valeus of one point to another\.

### func \(\*PointG2\) [Zero](<https://github.com/coinbase/kryptology/blob/master/pkg/core/curves/native/bls12-381/g2.go#L30>)

```go
func (p *PointG2) Zero() *PointG2
```



Generated by [gomarkdoc](<https://github.com/princjef/gomarkdoc>)
